PROMPT-TEST-CODE RULES

GOAL: "Translate ideas into code through strict test-first development"

REQUIRED CONTEXT
Each project MUST maintain:
- product_context.md: Intent and goals
- active_context.md: Current state
- system_architecture.md: Architecture patterns
- tech_context.md: Stack, frameworks
- progress.md: Phase tracking
- requirements.md: Feature specs
- test_scenarios.md: Gherkin scenarios
- technical_assumptions.md: Technical decisions

DIRECTORY STRUCTURE
src/
  main/             # Phase 3 only: Implementation
  test/
    spec/           # Phase 2 only: Feature specifications
      features/     # Gherkin scenarios
      contracts/    # Step interfaces
    impl/           # Phase 3 only: Test implementation
      steps/        # Step definitions

CORE PRINCIPLES

1. Autonomy
   * Default Mode:
     - Work autonomously
     - Make decisions independently
     - Keep moving forward
     - Document while doing
   * Stop Only For:
     - Phase transitions
     - Gate validations
     - Security concerns
     - Explicit USER request

2. Understanding First
   * Before ANY Change:
     - Understand current behavior
     - Know expected outcome
     - Have evidence for both
     - Document findings while proceeding
   * When Viewing Code:
     - Know what you're looking for
     - Know why you need it
     - Stay focused on current task
     - Note but don't chase tangents

WORKFLOW PHASES

1. Analysis Phase (STOP)
   * Required Context:
     - Verify all context files exist
     - Review all requirements
     - Understand system boundaries
     - Document technical assumptions
   * Deliverables:
     - Scope definition
     - System boundaries
     - Quality requirements
     - Technical assumptions
     ✓ USER approval required

2. Specification Phase (STOP)
   * Feature Writing:
     - Write Gherkin scenarios
     - Use ubiquitous language
     - Cover happy paths
     - Cover edge cases
   * Contract Creation:
     - Generate step interfaces
     - Define clear contracts
     - NO implementation details
     - Document assumptions
   * Files Allowed:
     - test/spec/features/*.feature
     - test/spec/contracts/*
   * Exit Criteria:
     - ALL scenarios written
     - ALL contracts defined
     - NO implementation logic
     - Documentation complete
     ✓ USER approval required

3. Implementation Phase
   * Entry Requirements:
     - Approved feature files
     - Complete step contracts
     - Clear understanding
     - USER approval received
   * Implementation Cycle:
     1. Pick ONE scenario
     2. Document current scenario
     3. Implement step definitions
     4. Implement production code
     5. Run ALL scenarios
     6. Report results
     7. Repeat if failures exist
   * Files Allowed:
     - src/main/*
     - test/impl/steps/*
   * Completion:
     - ALL scenarios pass
     - NO feature changes
     - Documentation updated

ERROR HANDLING

1. Scenario Failures
   * Expected (Continue):
     - New scenario failures
     - Documented edge cases
     - Known missing implementations
   * Unexpected (STOP):
     - Previously passing scenarios
     - Integration issues
     - Performance problems
     - Undocumented failures

2. Understanding Gaps
   * When Found:
     - Document the gap
     - Gather evidence needed
     - Continue current task
     - Return to gaps later

3. Architecture Issues
   * When Discovered:
     - STOP current implementation
     - Document discovery and impact
     - Request USER decision:
       * Continue current task
       * Switch to architectural fix
     - NO mixing of concerns

DOCUMENTATION

1. Continuous Documentation
   * Document While Working:
     - Decisions made
     - Problems found
     - Solutions implemented
     - Future considerations

2. Status Updates
   * Always Track in progress.md:
     - Current phase
     - Scenario status
     - Known issues
     - Next steps

VERIFICATION

1. Code Changes
   * Every Change Must:
     - Be complete
     - Be understood
     - Be tested
     - Be documented

2. Scenario Results
   * Every Run Must:
     - Execute full suite
     - Be analyzed fully
     - Drive next action
     - Update status

USER INTERACTION

1. Autonomous Operation
   * Proceed Without Approval For:
     - Step implementations
     - Production code
     - Bug fixes
     - Documentation updates
   * Prohibited Interactions:
     - Asking permission within phase
     - Seeking confirmation for standard decisions
     - Requesting approval outside gates
     - Breaking flow for non-critical issues

2. Required Approvals
   * Stop For USER Input On:
     - Phase transitions
     - Security decisions
     - Architecture changes
     - Feature file modifications
     - Explicit USER request

VIOLATION RECOVERY

1. Critical Violations (IMMEDIATE STOP)
   - Gate skipping
   - Missing approvals
   - Phase mixing
   - Feature file changes
   - Security concerns

2. Recovery Steps
   1. Stop all work
   2. Document violation
   3. Create recovery plan
   4. Get USER approval
   5. Execute recovery
   6. Verify resolution

UPDATE MEMORY AT EACH GATE